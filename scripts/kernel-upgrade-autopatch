#!/usr/bin/env zsh
#
# Requires: bc, bison, flex

set -e
set -o pipefail

while [[ $# -gt 0 ]]; do
    case "$1" in
        --check)
            check_only=yes
            ;;
        --work-dir)
            shift
            work_dir="$1"
            mkdir -p "$work_dir"
            ;;
        --clean)
            clean=yes
            ;;
        *)
            target="$1"
            ;;
    esac
    shift
done

clean () {
    cd
    [[ -n $clean ]] && rm -rf "$work_dir"
}
trap clean EXIT

# Read the target package from stdin if it wasn't given, since we're usually run as an alpm hook.
[[ -z $target ]] && read target

# Fetch the current remote version.
target_version="$(pacinfo --short "$target" | perl -ne 'print if not /^(local|\s)/ and s/^.*? (.*?) .*$/\1/')"
[[ -z $target_version ]] && printf "Unable to determine target version" && exit 2

asp update "$target"

# Use an existing work_dir if one is set, good for debugging.
work_dir="${work_dir:-$(mktemp --tmpdir=$XDG_CACHE_HOME --directory --suffix=.kernel-upgrade-autopatch)}"
cd "$work_dir" && printf "\nWorking in $work_dir\n\n"

asp checkout "$target" 2>/dev/null || printf "NOTE: Using existing checkout!\n"
cd "$target"

# Releases aren't tagged, so we have to look through the log.
# Checkout quietly to avoid the giant "detached HEAD" warning, but still show where we end up.
git checkout --quiet $(git log --fixed-strings --grep="$target_version" --max-count=1 --format=format:%H)
git log --oneline --max-count=1
cd "trunk"

if [[ -n $SUDO_USER && $UID -eq 0 ]]; then
    # makepkg can't be run as root, so downgrade to whoever we actually are.
    # We also need to be able to write into the directories.
    printf "Switching users to configure linux package...\n"
    MAKEPKG_USER="$SUDO_USER"
    chown -R "$MAKEPKG_USER" $work_dir
else
    MAKEPKG_USER="$USER"
fi

# Download the kernel source and apply the configuration.
sudo -u "$MAKEPKG_USER" makepkg --nodeps --nobuild

# Extract the path that the kernel gets stored in from the PKGBUILD. This is probably overkill.
kernel_src_dir=$(sudo -u "$MAKEPKG_USER" makepkg --printsrcinfo | perl -ne 'print $1 if /^\s+source = (.*?)::git\+.*linux\.git/')

patch_root="/home/vil/Code/kernel-module-patches"
patches=( $(cd "$patch_root" && find . -mindepth 1 -type 'f' -printf '%P\n') )

cd "src/$kernel_src_dir"

for patch in $patches; do
    git apply --verbose --whitespace=nowarn "$patch_root/$patch"
done

# If we only wanted to see if things applied cleanly, we're done.
[[ -n $check_only ]] && exit 0

# Otherwise, on to module building.
kernel_version=$(git describe --exact-match | perl -ne 'print $1 if /^v(.*)-arch\d+$/')
[[ -z $kernel_version ]] && echo "Unable to determine version from git tag!" && exit 3

uname_r="$(basename $(cd /usr/lib/modules && find -maxdepth 1 -name "${kernel_version}*"))"
[[ -z $uname_r ]] && echo "Kernel $kernel_version doesn't appear to be installed!" && exit 4
echo "Building modules for kernel $uname_r"

make modules_prepare

exec 5>&1  # I can't remember why this is here...
for patch in $patches; do
    module="$(dirname "$patch")"

    make "M=$module"

    echo "Made the following modules:"
    find "$module" -maxdepth 1 -name \*.ko

    ko_name="$(basename "$patch" | cut -d'.' -f1).ko"
    kernel-update-module \
        $(find "$module" -maxdepth 1 -name "$ko_name" | head -n1) \
        $uname_r
done
